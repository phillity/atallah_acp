Running experiment with 5 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     42.0 MiB     42.0 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     42.0 MiB      0.0 MiB       node_num = len(node_names)
   150     42.0 MiB      0.0 MiB       hierarchy = []
   151     42.0 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     42.0 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     42.0 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     42.0 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     42.0 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     42.0 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     42.0 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     42.0 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     42.0 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     42.0 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     42.0 MiB      0.0 MiB           if level == 0:
   167     42.0 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     42.0 MiB      0.0 MiB               for num in hierarchy[level]:
   170     42.0 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     42.0 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     42.0 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     42.0 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     42.0 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     42.0 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     42.0 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09937939999999967 seconds
decrypt_data_v2 ran in 0.10483640000000083 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     43.9 MiB     43.9 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     43.9 MiB      0.0 MiB       node_num = len(node_names)
   150     43.9 MiB      0.0 MiB       hierarchy = []
   151     43.9 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     43.9 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     43.9 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     43.9 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     43.9 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     43.9 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     43.9 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     43.9 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     43.9 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     43.9 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     43.9 MiB      0.0 MiB           if level == 0:
   167     43.9 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     43.9 MiB      0.0 MiB               for num in hierarchy[level]:
   170     43.9 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     43.9 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     43.9 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     43.9 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     43.9 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     43.9 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     43.9 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10319159999999972 seconds
decrypt_data_v2 ran in 0.1005193000000002 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     45.0 MiB     45.0 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     45.0 MiB      0.0 MiB       node_num = len(node_names)
   150     45.0 MiB      0.0 MiB       hierarchy = []
   151     45.0 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     45.0 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     45.0 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     45.0 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     45.0 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     45.0 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     45.0 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     45.0 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     45.0 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     45.0 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     45.0 MiB      0.0 MiB           if level == 0:
   167     45.0 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     45.0 MiB      0.0 MiB               for num in hierarchy[level]:
   170     45.0 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     45.0 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     45.0 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     45.0 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     45.0 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     45.0 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     45.0 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10183569999999875 seconds
decrypt_data_v2 ran in 0.11609439999999971 seconds
Ending experiment with 5 nodes
Running experiment with 10 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     45.8 MiB     45.8 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     45.8 MiB      0.0 MiB       node_num = len(node_names)
   150     45.8 MiB      0.0 MiB       hierarchy = []
   151     45.8 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     45.8 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     45.8 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     45.8 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     45.8 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     45.8 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     45.8 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     45.8 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     45.8 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     45.8 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     45.8 MiB      0.0 MiB           if level == 0:
   167     45.8 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     45.8 MiB      0.0 MiB               for num in hierarchy[level]:
   170     45.8 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     45.8 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     45.8 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     45.8 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     45.8 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     45.8 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     45.8 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10084559999999954 seconds
decrypt_data_v2 ran in 0.10433680000000223 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     46.2 MiB     46.2 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     46.2 MiB      0.0 MiB       node_num = len(node_names)
   150     46.2 MiB      0.0 MiB       hierarchy = []
   151     46.2 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     46.2 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     46.2 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     46.2 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     46.2 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     46.2 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     46.2 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     46.2 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     46.2 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     46.2 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     46.2 MiB      0.0 MiB           if level == 0:
   167     46.2 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     46.2 MiB      0.0 MiB               for num in hierarchy[level]:
   170     46.2 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     46.2 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     46.2 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     46.2 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     46.2 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     46.2 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     46.2 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10041929999999866 seconds
decrypt_data_v2 ran in 0.11378339999999909 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     47.4 MiB     47.4 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     47.4 MiB      0.0 MiB       node_num = len(node_names)
   150     47.4 MiB      0.0 MiB       hierarchy = []
   151     47.4 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     47.4 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     47.4 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     47.4 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     47.4 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     47.4 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     47.4 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     47.4 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     47.4 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     47.4 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     47.4 MiB      0.0 MiB           if level == 0:
   167     47.4 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     47.4 MiB      0.0 MiB               for num in hierarchy[level]:
   170     47.4 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     47.4 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     47.4 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     47.4 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     47.4 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     47.4 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     47.4 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09896039999999928 seconds
decrypt_data_v2 ran in 0.1006026999999996 seconds
Ending experiment with 10 nodes
Running experiment with 15 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     47.7 MiB     47.7 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     47.7 MiB      0.0 MiB       node_num = len(node_names)
   150     47.7 MiB      0.0 MiB       hierarchy = []
   151     47.7 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     47.7 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     47.7 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     47.7 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     47.7 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     47.7 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     47.7 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     47.7 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     47.7 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     47.7 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     47.7 MiB      0.0 MiB           if level == 0:
   167     47.7 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     47.7 MiB      0.0 MiB               for num in hierarchy[level]:
   170     47.7 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     47.7 MiB      0.1 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     47.7 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     47.7 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     47.7 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     47.7 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     47.7 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.0947081000000054 seconds
decrypt_data_v2 ran in 0.10710530000000063 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     51.7 MiB     51.7 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     51.7 MiB      0.0 MiB       node_num = len(node_names)
   150     51.7 MiB      0.0 MiB       hierarchy = []
   151     51.7 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     51.7 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     51.7 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     51.7 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     51.7 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     51.7 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     51.7 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     51.7 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     51.7 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     51.7 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     51.7 MiB      0.0 MiB           if level == 0:
   167     51.7 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     51.7 MiB      0.0 MiB               for num in hierarchy[level]:
   170     51.7 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     51.7 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     51.7 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     51.7 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     51.7 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     51.7 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     51.7 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09969790000000245 seconds
decrypt_data_v2 ran in 0.10948779999999658 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     54.5 MiB     54.5 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     54.5 MiB      0.0 MiB       node_num = len(node_names)
   150     54.5 MiB      0.0 MiB       hierarchy = []
   151     54.5 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     54.5 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     54.5 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     54.5 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     54.5 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     54.5 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     54.5 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     54.5 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     54.5 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     54.5 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     54.5 MiB      0.0 MiB           if level == 0:
   167     54.5 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     54.5 MiB      0.0 MiB               for num in hierarchy[level]:
   170     54.5 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     54.5 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     54.5 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     54.5 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     54.5 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     54.5 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     54.5 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10200449999999961 seconds
decrypt_data_v2 ran in 0.10867019999999172 seconds
Ending experiment with 15 nodes
Running experiment with 20 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     56.2 MiB     56.2 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     56.2 MiB      0.0 MiB       node_num = len(node_names)
   150     56.2 MiB      0.0 MiB       hierarchy = []
   151     56.2 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     56.2 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     56.2 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     56.2 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     56.2 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     56.2 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     56.2 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     56.2 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     56.2 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     56.2 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     56.2 MiB      0.0 MiB           if level == 0:
   167     56.2 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     56.2 MiB      0.0 MiB               for num in hierarchy[level]:
   170     56.2 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     56.2 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     56.2 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     56.2 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     56.2 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     56.2 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     56.2 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10550440000000094 seconds
decrypt_data_v2 ran in 0.10525989999999297 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     59.1 MiB     59.1 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     59.1 MiB      0.0 MiB       node_num = len(node_names)
   150     59.1 MiB      0.0 MiB       hierarchy = []
   151     59.1 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     59.1 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     59.1 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     59.1 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     59.1 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     59.1 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     59.1 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     59.1 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     59.1 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     59.1 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     59.1 MiB      0.0 MiB           if level == 0:
   167     59.1 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     59.1 MiB      0.0 MiB               for num in hierarchy[level]:
   170     59.1 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     59.1 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     59.1 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     59.1 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     59.1 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     59.1 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     59.1 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09868070000000273 seconds
decrypt_data_v2 ran in 0.1024571000000094 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     61.1 MiB     61.1 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     61.1 MiB      0.0 MiB       node_num = len(node_names)
   150     61.1 MiB      0.0 MiB       hierarchy = []
   151     61.1 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     61.1 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     61.1 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     61.1 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     61.1 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     61.1 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     61.1 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     61.1 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     61.1 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     61.1 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     61.1 MiB      0.0 MiB           if level == 0:
   167     61.1 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     61.1 MiB      0.0 MiB               for num in hierarchy[level]:
   170     61.1 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     61.1 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     61.1 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     61.1 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     61.1 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     61.1 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     61.1 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.1040502000000032 seconds
decrypt_data_v2 ran in 0.11142119999999522 seconds
Ending experiment with 20 nodes
Running experiment with 25 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     64.0 MiB     64.0 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     64.0 MiB      0.0 MiB       node_num = len(node_names)
   150     64.0 MiB      0.0 MiB       hierarchy = []
   151     64.0 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     64.0 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     64.0 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     64.0 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     64.0 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     64.0 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     64.0 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     64.0 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     64.0 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     64.0 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     64.0 MiB      0.0 MiB           if level == 0:
   167     64.0 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     64.0 MiB      0.0 MiB               for num in hierarchy[level]:
   170     64.0 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     64.0 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     64.0 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     64.0 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     64.0 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     64.0 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     64.0 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10581630000000075 seconds
decrypt_data_v2 ran in 0.1068774000000019 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     69.9 MiB     69.9 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     69.9 MiB      0.0 MiB       node_num = len(node_names)
   150     69.9 MiB      0.0 MiB       hierarchy = []
   151     69.9 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     69.9 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     69.9 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     69.9 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     69.9 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     69.9 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     69.9 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     69.9 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     69.9 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     69.9 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     69.9 MiB      0.0 MiB           if level == 0:
   167     69.9 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     69.9 MiB      0.0 MiB               for num in hierarchy[level]:
   170     69.9 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     69.9 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     69.9 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     69.9 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     69.9 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     69.9 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     69.9 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10076879999999733 seconds
decrypt_data_v2 ran in 0.11000330000001668 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     75.3 MiB     75.3 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     75.3 MiB      0.0 MiB       node_num = len(node_names)
   150     75.3 MiB      0.0 MiB       hierarchy = []
   151     75.3 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     75.3 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     75.3 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     75.3 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     75.3 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     75.3 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     75.3 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     75.3 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     75.3 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     75.3 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     75.3 MiB      0.0 MiB           if level == 0:
   167     75.3 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     75.3 MiB      0.0 MiB               for num in hierarchy[level]:
   170     75.3 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     75.3 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     75.3 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     75.3 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     75.3 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     75.3 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     75.3 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09837770000001456 seconds
decrypt_data_v2 ran in 0.10745159999999032 seconds
Ending experiment with 25 nodes
Running experiment with 30 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     80.1 MiB     80.1 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     80.1 MiB      0.0 MiB       node_num = len(node_names)
   150     80.1 MiB      0.0 MiB       hierarchy = []
   151     80.1 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     80.1 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     80.1 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     80.1 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     80.1 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     80.1 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     80.1 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     80.1 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     80.1 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     80.1 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     80.1 MiB      0.0 MiB           if level == 0:
   167     80.1 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     80.1 MiB      0.0 MiB               for num in hierarchy[level]:
   170     80.1 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     80.1 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     80.1 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     80.1 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     80.1 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     80.1 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     80.1 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09808599999999501 seconds
decrypt_data_v2 ran in 0.11030249999998887 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     84.8 MiB     84.8 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     84.8 MiB      0.0 MiB       node_num = len(node_names)
   150     84.8 MiB      0.0 MiB       hierarchy = []
   151     84.8 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     84.8 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     84.8 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     84.8 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     84.8 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     84.8 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     84.8 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     84.8 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     84.8 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     84.8 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     84.8 MiB      0.0 MiB           if level == 0:
   167     84.8 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     84.8 MiB      0.0 MiB               for num in hierarchy[level]:
   170     84.8 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     84.8 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     84.8 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     84.8 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     84.8 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     84.8 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     84.8 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09763310000002434 seconds
decrypt_data_v2 ran in 0.10836500000002047 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     90.5 MiB     90.5 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     90.5 MiB      0.0 MiB       node_num = len(node_names)
   150     90.5 MiB      0.0 MiB       hierarchy = []
   151     90.5 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     90.5 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     90.5 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     90.5 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     90.5 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     90.5 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     90.5 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     90.5 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     90.5 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     90.5 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     90.5 MiB      0.0 MiB           if level == 0:
   167     90.5 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     90.5 MiB      0.0 MiB               for num in hierarchy[level]:
   170     90.5 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     90.5 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     90.5 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     90.5 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     90.5 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     90.5 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     90.5 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09622790000000236 seconds
decrypt_data_v2 ran in 0.10767879999997376 seconds
Ending experiment with 30 nodes
Running experiment with 35 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132     95.2 MiB     95.2 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149     95.2 MiB      0.0 MiB       node_num = len(node_names)
   150     95.2 MiB      0.0 MiB       hierarchy = []
   151     95.2 MiB      0.0 MiB       curr_num_of_nodes = 0
   152     95.2 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153     95.2 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155     95.2 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156     95.2 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157     95.2 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158     95.2 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159     95.2 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162     95.2 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165     95.2 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166     95.2 MiB      0.0 MiB           if level == 0:
   167     95.2 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169     95.2 MiB      0.0 MiB               for num in hierarchy[level]:
   170     95.2 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171     95.2 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172     95.2 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174     95.2 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175     95.2 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176     95.2 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180     95.2 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.0969970999999532 seconds
decrypt_data_v2 ran in 0.10129649999998946 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    107.9 MiB    107.9 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    107.9 MiB      0.0 MiB       node_num = len(node_names)
   150    107.9 MiB      0.0 MiB       hierarchy = []
   151    107.9 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    107.9 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    107.9 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    107.9 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    107.9 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    107.9 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    107.9 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    107.9 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    107.9 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    107.9 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    107.9 MiB      0.0 MiB           if level == 0:
   167    107.9 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    107.9 MiB      0.0 MiB               for num in hierarchy[level]:
   170    107.9 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    107.9 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    107.9 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    107.9 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    107.9 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    107.9 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    107.9 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09593480000000909 seconds
decrypt_data_v2 ran in 0.11970239999999421 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    117.3 MiB    117.3 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    117.3 MiB      0.0 MiB       node_num = len(node_names)
   150    117.3 MiB      0.0 MiB       hierarchy = []
   151    117.3 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    117.3 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    117.3 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    117.3 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    117.3 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    117.3 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    117.3 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    117.3 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    117.3 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    117.3 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    117.3 MiB      0.0 MiB           if level == 0:
   167    117.3 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    117.3 MiB      0.0 MiB               for num in hierarchy[level]:
   170    117.3 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    117.3 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    117.3 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    117.3 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    117.3 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    117.3 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    117.3 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09719999999998663 seconds
decrypt_data_v2 ran in 0.0990479000000164 seconds
Ending experiment with 35 nodes
Running experiment with 40 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    127.4 MiB    127.4 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    127.4 MiB      0.0 MiB       node_num = len(node_names)
   150    127.4 MiB      0.0 MiB       hierarchy = []
   151    127.4 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    127.4 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    127.4 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    127.4 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    127.4 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    127.4 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    127.4 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    127.4 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    127.4 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    127.4 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    127.4 MiB      0.0 MiB           if level == 0:
   167    127.4 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    127.4 MiB      0.0 MiB               for num in hierarchy[level]:
   170    127.4 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    127.4 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    127.4 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    127.4 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    127.4 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    127.4 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    127.4 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10988689999999224 seconds
decrypt_data_v2 ran in 0.11003140000002531 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    137.5 MiB    137.5 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    137.5 MiB      0.0 MiB       node_num = len(node_names)
   150    137.5 MiB      0.0 MiB       hierarchy = []
   151    137.5 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    137.5 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    137.5 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    137.5 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    137.5 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    137.5 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    137.5 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    137.5 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    137.5 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    137.5 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    137.5 MiB      0.0 MiB           if level == 0:
   167    137.5 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    137.5 MiB      0.0 MiB               for num in hierarchy[level]:
   170    137.5 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    137.5 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    137.5 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    137.5 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    137.5 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    137.5 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    137.5 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.09564159999996491 seconds
decrypt_data_v2 ran in 0.10325749999998379 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    147.9 MiB    147.9 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    147.9 MiB      0.0 MiB       node_num = len(node_names)
   150    147.9 MiB      0.0 MiB       hierarchy = []
   151    147.9 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    147.9 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    147.9 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    147.9 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    147.9 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    147.9 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    147.9 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    147.9 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    147.9 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    147.9 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    147.9 MiB      0.0 MiB           if level == 0:
   167    147.9 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    147.9 MiB      0.0 MiB               for num in hierarchy[level]:
   170    147.9 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    147.9 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    147.9 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    147.9 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    147.9 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    147.9 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    147.9 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10590689999997949 seconds
decrypt_data_v2 ran in 0.10564780000004248 seconds
Ending experiment with 40 nodes
Running experiment with 45 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    157.0 MiB    157.0 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    157.0 MiB      0.0 MiB       node_num = len(node_names)
   150    157.0 MiB      0.0 MiB       hierarchy = []
   151    157.0 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    157.0 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    157.0 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    157.0 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    157.0 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    157.0 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    157.0 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    157.0 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    157.0 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    157.0 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    157.0 MiB      0.0 MiB           if level == 0:
   167    157.0 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    157.0 MiB      0.0 MiB               for num in hierarchy[level]:
   170    157.0 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    157.0 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    157.0 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    157.0 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    157.0 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    157.0 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    157.0 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10661979999997584 seconds
decrypt_data_v2 ran in 0.11502370000005158 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    182.2 MiB    182.2 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    182.2 MiB      0.0 MiB       node_num = len(node_names)
   150    182.2 MiB      0.0 MiB       hierarchy = []
   151    182.2 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    182.2 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    182.2 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    182.2 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    182.2 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    182.2 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    182.2 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    182.2 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    182.2 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    182.2 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    182.2 MiB      0.0 MiB           if level == 0:
   167    182.2 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    182.2 MiB      0.0 MiB               for num in hierarchy[level]:
   170    182.2 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    182.2 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    182.2 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    182.2 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    182.2 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    182.2 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    182.2 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10774529999991955 seconds
decrypt_data_v2 ran in 0.10991709999996147 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    201.6 MiB    201.6 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    201.6 MiB      0.0 MiB       node_num = len(node_names)
   150    201.6 MiB      0.0 MiB       hierarchy = []
   151    201.6 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    201.6 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    201.6 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    201.6 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    201.6 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    201.6 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    201.6 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    201.6 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    201.6 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    201.6 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    201.6 MiB      0.0 MiB           if level == 0:
   167    201.6 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    201.6 MiB      0.0 MiB               for num in hierarchy[level]:
   170    201.6 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    201.6 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    201.6 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    201.6 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    201.6 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    201.6 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    201.6 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.1071706999999833 seconds
decrypt_data_v2 ran in 0.10512400000004618 seconds
Ending experiment with 45 nodes
Running experiment with 50 nodes, 10 users per node
Run number 1
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    221.9 MiB    221.9 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    221.9 MiB      0.0 MiB       node_num = len(node_names)
   150    221.9 MiB      0.0 MiB       hierarchy = []
   151    221.9 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    221.9 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    221.9 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    221.9 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    221.9 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    221.9 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    221.9 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    221.9 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    221.9 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    221.9 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    221.9 MiB      0.0 MiB           if level == 0:
   167    221.9 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    221.9 MiB      0.0 MiB               for num in hierarchy[level]:
   170    221.9 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    221.9 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    221.9 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    221.9 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    221.9 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    221.9 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    221.9 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10605449999991379 seconds
decrypt_data_v2 ran in 0.11411450000002787 seconds
Run number 2
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    241.4 MiB    241.4 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    241.4 MiB      0.0 MiB       node_num = len(node_names)
   150    241.4 MiB      0.0 MiB       hierarchy = []
   151    241.4 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    241.4 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    241.4 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    241.4 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    241.4 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    241.4 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    241.4 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    241.4 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    241.4 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    241.4 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    241.4 MiB      0.0 MiB           if level == 0:
   167    241.4 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    241.4 MiB      0.0 MiB               for num in hierarchy[level]:
   170    241.4 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    241.4 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    241.4 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    241.4 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    241.4 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    241.4 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    241.4 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.10493229999997311 seconds
decrypt_data_v2 ran in 0.1103190999999697 seconds
Run number 3
Filename: main.py

Line #    Mem usage    Increment   Line Contents
================================================
   132    261.2 MiB    261.2 MiB   @profile
   133                             def create_random_dag(node_names, node_user_map):
   134                                 """
   135                                 Randomly generates a DAG graph. Start of by creating a list that represents the hierarchy.
   136                                 Each element in the list is another list showing the nodes in that level.
   137                                 The number of nodes in each level is random. Then use this hierarchy to create nodes
   138                                 and edges between nodes. Edges are created by randomly selecting a node in the previous level
   139                                 as a parent.
   140                             
   141                                 Args:
   142                                     node_names (list): list of all the nodes to be used
   143                                     node_user_map (dict): use node name as a key to get all the users for node
   144                                 
   145                                 Returns:
   146                                     graph (DAG): returns a randomly generated DAG object
   147                                 """
   148                                 # the number of nodes to create will be the same as the length of the node_names list
   149    261.2 MiB      0.0 MiB       node_num = len(node_names)
   150    261.2 MiB      0.0 MiB       hierarchy = []
   151    261.2 MiB      0.0 MiB       curr_num_of_nodes = 0
   152    261.2 MiB      0.0 MiB       hierarchy.append([curr_num_of_nodes])
   153    261.2 MiB      0.0 MiB       curr_num_of_nodes += 1
   154                                 # create a hierarchy for the nodes
   155    261.2 MiB      0.0 MiB       while curr_num_of_nodes < node_num:
   156    261.2 MiB      0.0 MiB           nodes_to_create = random.choice(list(range(curr_num_of_nodes, node_num)))
   157    261.2 MiB      0.0 MiB           level = [i for i in range(curr_num_of_nodes, nodes_to_create+1)]
   158    261.2 MiB      0.0 MiB           curr_num_of_nodes += len(level)
   159    261.2 MiB      0.0 MiB           hierarchy.append(level)
   160                             
   161                                 # create empty graph object without passing in input matrix
   162    261.2 MiB      0.0 MiB       graph = DAG(node_names, node_user_map)
   163                             
   164                                 # use the hierarchy to create the nodes and edges
   165    261.2 MiB      0.0 MiB       for level in range(len(hierarchy)):
   166    261.2 MiB      0.0 MiB           if level == 0:
   167    261.2 MiB      0.0 MiB               graph.add_node(f"Node 0", node_user_map["Node 0"])
   168                                     else:
   169    261.2 MiB      0.0 MiB               for num in hierarchy[level]:
   170    261.2 MiB      0.0 MiB                   curr_node_name = f"Node {num}"
   171    261.2 MiB      0.0 MiB                   graph.add_node(curr_node_name, node_user_map[curr_node_name])
   172    261.2 MiB      0.0 MiB                   parent_level = level-1
   173                                             # randomly choose a node a level above in the hierarchy as the parent
   174    261.2 MiB      0.0 MiB                   parent_node_num = random.choice(hierarchy[parent_level])
   175    261.2 MiB      0.0 MiB                   parent_node_name = f"Node {parent_node_num}"
   176    261.2 MiB      0.0 MiB                   graph.add_edge(parent_node_name, curr_node_name)
   177                                 
   178                                 # for node in graph.node_list:
   179                                     # print(f"node: {node}, edges: {graph.node_list[node].edges.keys()}")
   180    261.2 MiB      0.0 MiB       return graph


decrypt_data_v1 ran in 0.1010567999999239 seconds
decrypt_data_v2 ran in 0.10824380000008205 seconds
Ending experiment with 50 nodes
